---
title: RustでWebAssemblyインタプリタ作った話
date: "2019-12-02T10:21:22.931Z"
update: "2019-12-02T10:21:22.931Z"
tags: ["webassembly"]
name: wasm-rs
lang: ja
otherLang: []
---

## リポジトリ
https://github.com/kgtkr/wasm-rs

## 仕様書
https://webassembly.github.io/spec/core/index.html

## wasmはどう実行される
1. バイナリをデコード  
   バイナリデータを内部表現にデコードします。  
2. 検証  
   wasmのコードが正しいかの検証を行います。  
   例えば存在しない関数を呼び出していないか、関数の引数に渡す型が正しいのかといった検証です。  
3. 実行  
   wasmの命令を実行します。  
   スタックマシンの形式になっています。

今回は検証フェーズと、小数命令の一部評価が未実装です。  
またバイナリのデコードだけでなく、エンコード処理も実装しました。

## AST定義
仕様書の`Structure`を読んでなるべくその通りにデータ構造を定義しました。
命令は`inter = block [inter] | ...`のようにツリー構造で定義する方法と、`inter = block | end | ...`のようにフラットに定義する方法がありますが今回は仕様書に合わせてツリー構造で定義しました。

## バイナリのデコード、エンコード
仕様書の`Binary Format`を読みましょう。  
バイナリ容量を圧縮するためにleb128という数値の可変長エンコード形式が様々な場所で使われています。  
デコードにはRustのnomというパーサーコンビネーターライブラリを使いました。  
proptestというテストツールを使うことでテストツールを使うことでASTをランダムで自動生成してエンコード・デコードで元に戻るかというテストをしてみましたが、再帰データ構造では自動生成出来ないらしく再帰構造を含まないASTのみ行いました。  

## 実行
スタックマシンとなっていますがなるべく仕様書通りに実装するために3種類のスタックを持つようにしました。  
Frameスタックという関数が呼び出されると積まれるローカル変数などの情報を持つスタックがトップにあり、Frameスタックの要素はLabelスタックという制御構文に入ると積まれるスタックを持っています。そしてLabelスタックの要素はi32/i64/f32/f64の数値型のスタックを持っています。
そして命令は1ステップずつ実行され、そのスタックで完結しない命令は親に投げて親で処理する実装にしました。例えば制御命令はLabelスタックを操作する必要があるのでLabelスタックの要素では完結しないのでLabelスタックを持つFrameスタックに処理を任せます。関数呼び出しはFrameスタックの要素では完結しないのでFrameスタックを持つルートに処理を任せます。
命令の実行はこんな感じです。
wasmでは可変メモリを複数のモジュールインスタンスが共有することがありますが、Rustでは`&mut`を複数作ることが出来ないのでArenaパターンか、`Rc<RefCell<T>>`を使う必要がありますが今回は後者で行いました。ただ汚いのでここはもう少し考えたいです。
またモジュールインスタンスは関数を持ち関数インスタンスはモジュールインスタンスを持つという循環構造になっているのでかなり初期化がつらいという問題もあります。循環参照になるとメモリリークするので関数インスタンスが持つモジュールインスタンスは`Rc`ではなく`Weak`を使っていますがここも綺麗にしたいです。


## バグった、公式にテストケースが
命令を実装していると細かいバグを埋め込むことがあり、そのデバッグが大変です。
その時は公式がテストケースを用意しているのでそれを使いましょう。

https://github.com/WebAssembly/spec/tree/master/test/core

wastというwatの拡張フォーマットになっており、これはwabtのwast2jsonを使うことでwasm+jsonに変換することができます。
jsonをいい感じに読み込んでwasmを自作インタプリタで動かすことで簡単にテストをすることができ、デバッグに役立ちます。

## md5の実行
Rustでmd5を計算するコードをwasmにコンパイルし、それを自作インタプリタ上で動かしてみました。
やり取りはCStringを使っています。

## 自作言語を自作インタプリタで動かす
一年前にHaskellでwasmにコンパイルする自作言語を作ったので、それを実行してみたところ上手く動かすことができました。

## 自作インタプリタ上で自作インタプリタを動かす
Rustはwasmにコンパイルすることができるので自作インタプリタ上で自作言語を動かすコードをwasmにコンパイルし、それを自作インタプリタで動かしてみました。
上手く動かすことが出来ましたが、実行に数分かかり、かなり遅いのでパフォーマンスの改善も多少はしたいです。

## これからやること
まだ不完全なのでとりあえず小数命令の実装出来てないやつを実装してしまいたいです。
また検証フェーズの実装を一切行っていないのでそこもして、公式のwastテストケースは全て通る事を目指したいです。
